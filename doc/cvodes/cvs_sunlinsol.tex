%===================================================================================
\chapter{Description of the SUNLinearSolver module}\label{s:sunlinsol}
%===================================================================================
\index{SUNLinearSolver@\texttt{SUNLinearSolver} module}
\input{sunlinsol_generic}


%---------------------------------------------------------------------------
\section{CVODES SUNLinearSolver interface}
\label{s:sunlinsol_interface}
%---------------------------------------------------------------------------

Table \ref{t:sunlinsoluse} below lists the {\sunlinsol} module linear solver
functions used within the {\cvls} interface. As with the {\sunmatrix} module, we
emphasize that the {\cvodes} user does not need to know detailed usage of linear
solver functions by the {\cvodes} code modules in order to use {\cvodes}. The
information is presented as an implementation detail for the interested reader.

The linear solver functions listed below are marked with \cm to
indicate that they are required, or with $\dagger$ to indicate that
they are only called if they are non-\id{NULL} in the {\sunlinsol}
implementation that is being used. Note:
\begin{enumerate}
\item \id{SUNLinSolNumIters} is only used to accumulate overall
  iterative linear solver statistics.  If it is not implemented by
  the {\sunlinsol} module, then {\cvls} will consider all solves as
  requiring zero iterations.
\item Although {\cvls} does not call \id{SUNLinSolLastFlag}
  directly, this routine is available for users to query linear solver
  issues directly.
\item Although {\cvls} does not call \id{SUNLinSolFree}
  directly, this routine should be available for users to call when
  cleaning up from a simulation.
\end{enumerate}

\begin{table}[htb]
\centering
\caption{List of linear solver function usage in the {\cvls} interface}\label{t:sunlinsoluse}
\medskip
\begin{tabular}{|r|c|c|c|} \hline
                                                    & 
\begin{sideways}{DIRECT}             \end{sideways} & 
\begin{sideways}{ITERATIVE}          \end{sideways} & 
\begin{sideways}{MATRIX\_ITERATIVE}  \end{sideways} \\ \hline\hline
%                                  DIRECT       ITER    & MAT-ITER  
\id{SUNLinSolGetType}           &    \cm    &    \cm    &   \cm     \\ \hline
\id{SUNLinSolSetATimes}         & $\dagger$ &    \cm    & $\dagger$ \\ \hline
\id{SUNLinSolSetPreconditioner} & $\dagger$ & $\dagger$ & $\dagger$ \\ \hline
\id{SUNLinSolSetScalingVectors} & $\dagger$ & $\dagger$ & $\dagger$ \\ \hline
\id{SUNLinSolInitialize}        &    \cm    &    \cm    &   \cm     \\ \hline
\id{SUNLinSolSetup}             &    \cm    &    \cm    &   \cm     \\ \hline
\id{SUNLinSolSolve}             &    \cm    &    \cm    &   \cm     \\ \hline
$^1$\id{SUNLinSolNumIters}      &           & $\dagger$ & $\dagger$ \\ \hline
$^2$\id{SUNLinSolLastFlag}      &           &           &           \\ \hline
$^3$\id{SUNLinSolFree}          &           &           &           \\ \hline
\id{SUNLinSolSpace}             & $\dagger$ & $\dagger$ & $\dagger$ \\ \hline
\end{tabular}
\end{table}

Since there are a wide range of potential {\sunlinsol} use cases, the following
subsections describe some details of the {\cvls} interface, in the case that
interested users wish to develop custom {\sunlinsol} modules.

%---------------------------------------------------------------------------
\subsection{Lagged matrix information}
\label{ss:sunlinsol_lagged_matrix}
%---------------------------------------------------------------------------

If the {\sunlinsol} object self-identifies as having type
\id{SUNLINEARSOLVER\_DIRECT} or \\ \noindent
\id{SUNLINEARSOLVER\_MATRIX\_ITERATIVE}, then the {\sunlinsol} object solves a
linear system \emph{defined} by a {\sunmatrix} object. {\cvls} will update the
matrix information infrequently according to the strategies outlined in
\S\ref{ss:ivp_sol}. When solving a linear system
\[
  M\bar{x} = b \quad\Leftrightarrow\quad (I-\bar{\gamma} J)\bar{x} = b
\]
it is likely that the value $\bar{\gamma}$ used to construct $M$
differs from the current value of $\gamma$ in the linear multistep method, since
$M$ is updated infrequently.  Therefore, after calling the
{\sunlinsol}-provided \id{SUNLinSolSolve} routine, we test whether
$\gamma / \bar{\gamma} \ne 1$, and if this is the case we scale
the solution $\bar{x}$ to obtain the desired linear system
solution $x$ via
\begin{equation}
  \label{eq:rescaling}
  x = \frac{2}{1 + \gamma / \bar{\gamma}} \bar{x}.
\end{equation}
For values of $\gamma/\bar{\gamma}$ that are ``close'' to 1, this
rescaling approximately solves the original linear system, as
discussed below.  We first note that the equation \eqref{eq:rescaling}
is equivalent to
\[
  \bar{x} = \frac12 \left(1 + \frac{\gamma}{\bar{\gamma}}\right)x.
\]
Adding the two equations $(I-\gamma J)x=b$ and
$(I-\bar{\gamma}J)\bar{x}=b$, and inserting the above relationship, we
have
\begin{align*}
  2b &= (I-\gamma J)x + (I-\bar{\gamma}J) \\
     &= x - \gamma Jx + \bar{x} - J\left(\bar{\gamma}\bar{x}\right)\\
     &= \frac32\left(I - \gamma J\right)x + \frac12\left(\frac{\gamma}{\bar{\gamma}}I - \bar{\gamma} J\right)x\\
     &= \frac32 b + \frac12\left(\frac{\gamma}{\bar{\gamma}}I - \bar{\gamma} J\right)x.
\end{align*}
When $\gamma/\bar{\gamma}\approx 1$, this latter term is approximately
equal to $\frac12 b$.

%---------------------------------------------------------------------------
\subsection{Iterative linear solver tolerance}
\label{ss:sunlinsol_iterative_tolerance}
%---------------------------------------------------------------------------

If the {\sunlinsol} object self-identifies as having type
\id{SUNLINEARSOLVER\_ITERATIVE} or \newline
\id{SUNLINEARSOLVER\_MATRIX\_ITERATIVE} then {\cvls} will set the input
tolerance \id{delta} as described in \S\ref{ss:ivp_sol}. However, if the
iterative linear solver does not support scaling matrices (i.e., the \newline
\id{SUNLinSolSetScalingVectors} routine is \id{NULL}), then {\cvls} will attempt 
to adjust the linear solver tolerance to account for this lack of functionality.
To this end, the following assumptions are made:
\begin{enumerate}
\item All solution components have similar magnitude; hence the error
  weight vector $W$ used in the WRMS norm (see \S\ref{ss:ivp_sol})
  should satisfy the assumption 
  \[
    W_i \approx W_{mean},\quad \text{for}\quad i=0,\ldots,n-1.
  \]
\item The {\sunlinsol} object uses a standard 2-norm to measure
  convergence.
\end{enumerate}

Since {\cvode} uses identical left and right scaling matrices,
$S_1 = S_2 = S = \operatorname{diag}(W)$, then the linear
solver convergence requirement is converted as follows
(using the notation from equations
\eqref{eq:transformed_linear_system}-\eqref{eq:transformed_linear_system_components}):
\begin{align*}
  &\left\| \tilde{b} - \tilde{A} \tilde{x} \right\|_2  <  \text{tol}\\
  \Leftrightarrow \quad & \left\| S P_1^{-1} b - S P_1^{-1} A x \right\|_2  <  \text{tol}\\
  \Leftrightarrow \quad & \sum_{i=0}^{n-1} \left[W_i \left(P_1^{-1} (b - A x)\right)_i\right]^2  <  \text{tol}^2\\
  \Leftrightarrow \quad & W_{mean}^2 \sum_{i=0}^{n-1} \left[\left(P_1^{-1} (b - A x)\right)_i\right]^2  <  \text{tol}^2\\
  \Leftrightarrow \quad & \sum_{i=0}^{n-1} \left[\left(P_1^{-1} (b - A x)\right)_i\right]^2  <  \left(\frac{\text{tol}}{W_{mean}}\right)^2\\
  \Leftrightarrow \quad & \left\| P_1^{-1} (b - A x)\right\|_2  <  \frac{\text{tol}}{W_{mean}}
\end{align*}
Therefore the tolerance scaling factor
\[
  W_{mean} = \|W\|_2 / \sqrt{n}
\]
is computed and the scaled tolerance \id{delta}$= \text{tol} / W_{mean}$ is
supplied to the {\sunlinsol} object.

%---------------------------------------------------------------------------
% sunlinsol module sections
%---------------------------------------------------------------------------

\input{sunlinsol_dense}
\input{sunlinsol_band}
\input{sunlinsol_lapackdense}
\input{sunlinsol_lapackband}
\input{sunlinsol_klu}
\input{sunlinsol_superludist}
\input{sunlinsol_superlumt}
\input{sunlinsol_spgmr}
\input{sunlinsol_spfgmr}
\input{sunlinsol_spbcgs}
\input{sunlinsol_sptfqmr}
\input{sunlinsol_pcg}
\input{sunlinsol_examples}
